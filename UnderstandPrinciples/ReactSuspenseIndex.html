<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>React Suspense æ¨¡æ‹Ÿå®ç°</title>
    <style>
        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            max-width: 800px;
            margin: 0 auto;
            padding: 20px;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: #333;
            min-height: 100vh;
        }

        .container {
            background: white;
            border-radius: 12px;
            padding: 30px;
            box-shadow: 0 10px 30px rgba(0,0,0,0.2);
        }

        h1 {
            color: #2c3e50;
            text-align: center;
            margin-bottom: 30px;
        }

        .demo-section {
            margin: 20px 0;
            padding: 20px;
            border: 2px solid #e3f2fd;
            border-radius: 8px;
            background: #f8f9fa;
        }

        .loading {
            display: flex;
            align-items: center;
            justify-content: center;
            padding: 20px;
            color: #666;
            font-style: italic;
        }

        .spinner {
            width: 20px;
            height: 20px;
            border: 2px solid #f3f3f3;
            border-top: 2px solid #3498db;
            border-radius: 50%;
            animation: spin 1s linear infinite;
            margin-right: 10px;
        }

        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }

        .user-card {
            background: linear-gradient(45deg, #FF6B6B, #4ECDC4);
            color: white;
            padding: 20px;
            border-radius: 8px;
            margin: 10px 0;
        }

        .error {
            background: #ffebee;
            color: #c62828;
            padding: 15px;
            border-radius: 8px;
            border-left: 4px solid #c62828;
        }

        button {
            background: linear-gradient(45deg, #667eea, #764ba2);
            color: white;
            border: none;
            padding: 12px 24px;
            border-radius: 6px;
            cursor: pointer;
            font-size: 16px;
            margin: 10px 5px;
            transition: transform 0.2s;
        }

        button:hover {
            transform: translateY(-2px);
        }

        .code-section {
            background: #f5f5f5;
            padding: 15px;
            border-radius: 8px;
            margin: 15px 0;
            font-family: 'Courier New', monospace;
            font-size: 14px;
            overflow-x: auto;
        }

        .status {
            padding: 10px;
            margin: 10px 0;
            border-radius: 6px;
            font-weight: bold;
        }

        .status.pending { background: #fff3cd; color: #856404; }
        .status.resolved { background: #d4edda; color: #155724; }
        .status.rejected { background: #f8d7da; color: #721c24; }
    </style>
</head>
<body>
    <div class="container">
        <h1>ğŸš€ React Suspense æ¨¡æ‹Ÿå®ç°</h1>
        
        <div class="demo-section">
            <h3>ğŸ“Š çŠ¶æ€ç›‘æ§</h3>
            <div id="status" class="status pending">ç­‰å¾…æ“ä½œ...</div>
        </div>

        <div class="demo-section">
            <h3>ğŸ® æ§åˆ¶é¢æ¿</h3>
            <button onclick="loadUser()">åŠ è½½ç”¨æˆ·æ•°æ®</button>
            <button onclick="loadUserWithError()">æ¨¡æ‹ŸåŠ è½½é”™è¯¯</button>
            <button onclick="reset()">é‡ç½®</button>
        </div>

        <div class="demo-section">
            <h3>ğŸ“± Suspense å®¹å™¨</h3>
            <div id="suspense-container">
                <div class="loading">
                    <div class="spinner"></div>
                    å‡†å¤‡å°±ç»ªï¼Œç‚¹å‡»æŒ‰é’®å¼€å§‹æ¼”ç¤º...
                </div>
            </div>
        </div>

        <div class="demo-section">
            <h3>ğŸ’¡ å®ç°åŸç†è¯´æ˜</h3>
            <div class="code-section">
                <strong>æ ¸å¿ƒæ¦‚å¿µï¼š</strong><br>
                1. Promise æŠ›å‡ºæœºåˆ¶ï¼šç»„ä»¶æŠ›å‡º Promise æ¥æš‚åœæ¸²æŸ“<br>
                2. é”™è¯¯è¾¹ç•Œï¼šæ•è· Promise å¹¶æ˜¾ç¤º fallback<br>
                3. çŠ¶æ€ç®¡ç†ï¼šè·Ÿè¸ª Promise çŠ¶æ€å¹¶é‡æ–°æ¸²æŸ“<br>
                4. ç¼“å­˜æœºåˆ¶ï¼šé¿å…é‡å¤è¯·æ±‚ç›¸åŒæ•°æ®
            </div>
        </div>
    </div>

    <script>
        // æ¨¡æ‹Ÿ React Suspense çš„æ ¸å¿ƒå®ç°
        class SuspenseSimulator {
            constructor(containerId, fallbackElement) {
                this.container = document.getElementById(containerId);
                this.fallback = fallbackElement;
                this.promiseCache = new Map();
                this.isRendering = false;
            }

            // æ ¸å¿ƒæ–¹æ³•ï¼šæ¸²æŸ“ç»„ä»¶æˆ–æ˜¾ç¤º fallback
            render(componentFn, props = {}) {
                try {
                    this.isRendering = true;
                    const result = componentFn(props);
                    this.container.innerHTML = result;
                    this.updateStatus('resolved', 'âœ… æ•°æ®åŠ è½½å®Œæˆ');
                } catch (error) {
                    if (this.isPromise(error)) {
                        // è¿™æ˜¯ä¸€ä¸ª Promiseï¼Œæ˜¾ç¤º loading çŠ¶æ€
                        this.handleSuspense(error, componentFn, props);
                    } else {
                        // è¿™æ˜¯ä¸€ä¸ªçœŸæ­£çš„é”™è¯¯
                        this.handleError(error);
                    }
                } finally {
                    this.isRendering = false;
                }
            }

            // æ£€æŸ¥æ˜¯å¦æ˜¯ Promise
            isPromise(obj) {
                return obj && typeof obj.then === 'function';
            }

            // å¤„ç† Suspenseï¼ˆPromise è¢«æŠ›å‡ºï¼‰
            handleSuspense(promise, componentFn, props) {
                this.container.innerHTML = this.fallback;
                this.updateStatus('pending', 'â³ æ­£åœ¨åŠ è½½æ•°æ®...');

                promise.then(() => {
                    // Promise å®Œæˆåé‡æ–°æ¸²æŸ“
                    this.render(componentFn, props);
                }).catch(error => {
                    this.handleError(error);
                });
            }

            // å¤„ç†é”™è¯¯
            handleError(error) {
                this.container.innerHTML = `
                    <div class="error">
                        <strong>âŒ åŠ è½½å¤±è´¥</strong><br>
                        ${error.message}
                    </div>
                `;
                this.updateStatus('rejected', 'âŒ æ•°æ®åŠ è½½å¤±è´¥');
            }

            // æ›´æ–°çŠ¶æ€æ˜¾ç¤º
            updateStatus(type, message) {
                const statusEl = document.getElementById('status');
                statusEl.className = `status ${type}`;
                statusEl.textContent = message;
            }
        }

        // æ¨¡æ‹Ÿæ•°æ®è·å–å·¥å…·
        class DataFetcher {
            static cache = new Map();

            // åˆ›å»ºä¸€ä¸ª"å¯æš‚åœ"çš„èµ„æº
            static createSuspenseResource(key, fetcher) {
                if (this.cache.has(key)) {
                    const cached = this.cache.get(key);
                    if (cached.status === 'resolved') {
                        return cached.data;
                    } else if (cached.status === 'rejected') {
                        throw cached.error;
                    } else {
                        // ä»åœ¨ pending çŠ¶æ€ï¼ŒæŠ›å‡º Promise
                        throw cached.promise;
                    }
                }

                // åˆ›å»ºæ–°çš„ Promise
                const promise = fetcher().then(
                    data => {
                        this.cache.set(key, { status: 'resolved', data });
                        return data;
                    },
                    error => {
                        this.cache.set(key, { status: 'rejected', error });
                        throw error;
                    }
                );

                this.cache.set(key, { status: 'pending', promise });
                throw promise; // å…³é”®ï¼šæŠ›å‡º Promise æ¥æš‚åœç»„ä»¶æ¸²æŸ“
            }

            // æ¸…é™¤ç¼“å­˜
            static clearCache() {
                this.cache.clear();
            }
        }

        // æ¨¡æ‹Ÿå¼‚æ­¥æ•°æ®è·å–
        function fetchUserData(shouldError = false) {
            return new Promise((resolve, reject) => {
                setTimeout(() => {
                    if (shouldError) {
                        reject(new Error('ç½‘ç»œè¯·æ±‚å¤±è´¥ï¼Œè¯·ç¨åé‡è¯•'));
                    } else {
                        resolve({
                            id: Math.floor(Math.random() * 1000),
                            name: ['å¼ ä¸‰', 'æå››', 'ç‹äº”', 'èµµå…­'][Math.floor(Math.random() * 4)],
                            email: 'user@example.com',
                            avatar: 'ğŸ‘¨â€ğŸ’»'
                        });
                    }
                }, Math.random() * 2000 + 1000); // 1-3ç§’éšæœºå»¶è¿Ÿ
            });
        }

        // ä½¿ç”¨ Suspense çš„ç»„ä»¶
        function UserProfile(props) {
            // è¿™é‡Œä¼šæŠ›å‡º Promiseï¼ˆå¦‚æœæ•°æ®è¿˜æ²¡åŠ è½½å®Œæˆï¼‰
            const user = DataFetcher.createSuspenseResource(
                props.userId || 'default-user',
                () => fetchUserData(props.shouldError)
            );

            // åªæœ‰å½“æ•°æ®åŠ è½½å®Œæˆåæ‰ä¼šæ‰§è¡Œåˆ°è¿™é‡Œ
            return `
                <div class="user-card">
                    <h3>${user.avatar} ${user.name}</h3>
                    <p><strong>ID:</strong> ${user.id}</p>
                    <p><strong>é‚®ç®±:</strong> ${user.email}</p>
                    <p><em>âœ¨ æ•°æ®é€šè¿‡ Suspense å¼‚æ­¥åŠ è½½</em></p>
                </div>
            `;
        }

        // åˆ›å»º Suspense å®ä¾‹
        const suspense = new SuspenseSimulator('suspense-container', `
            <div class="loading">
                <div class="spinner"></div>
                æ­£åœ¨åŠ è½½ç”¨æˆ·æ•°æ®ï¼Œè¯·ç¨å€™...
            </div>
        `);

        // æ¼”ç¤ºå‡½æ•°
        function loadUser() {
            DataFetcher.clearCache();
            suspense.render(UserProfile, { userId: `user-${Date.now()}` });
        }

        function loadUserWithError() {
            DataFetcher.clearCache();
            suspense.render(UserProfile, { 
                userId: `error-user-${Date.now()}`, 
                shouldError: true 
            });
        }

        function reset() {
            DataFetcher.clearCache();
            suspense.container.innerHTML = `
                <div class="loading">
                    <div class="spinner"></div>
                    å‡†å¤‡å°±ç»ªï¼Œç‚¹å‡»æŒ‰é’®å¼€å§‹æ¼”ç¤º...
                </div>
            `;
            suspense.updateStatus('pending', 'ç­‰å¾…æ“ä½œ...');
        }

        // æ·»åŠ ä¸€äº›è¯´æ˜ä¿¡æ¯
        console.log(`
ğŸ¯ React Suspense æ¨¡æ‹Ÿå®ç°æ¼”ç¤º

æ ¸å¿ƒåŸç†ï¼š
1. ç»„ä»¶åœ¨éœ€è¦å¼‚æ­¥æ•°æ®æ—¶æŠ›å‡º Promise
2. Suspense è¾¹ç•Œæ•è· Promise å¹¶æ˜¾ç¤º fallback UI
3. Promise å®Œæˆåé‡æ–°æ¸²æŸ“ç»„ä»¶
4. é”™è¯¯è¾¹ç•Œå¤„ç†å¤±è´¥æƒ…å†µ

è¿™ä¸ªå®ç°å±•ç¤ºäº†ï¼š
âœ… Promise æŠ›å‡ºæœºåˆ¶
âœ… çŠ¶æ€ç®¡ç†å’Œç¼“å­˜
âœ… é”™è¯¯å¤„ç†
âœ… é‡æ–°æ¸²æŸ“é€»è¾‘
        `);
    </script>
</body>
</html>